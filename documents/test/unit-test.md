# 단위 테스트

덕키는 TDD 를 기본으로 합니다. 하지만 스냅샷 테스트는 TDD 가 불가능함으로 단위 테스트와 UI 테스트만 TDD 를 진행합니다.

### 왜?

덕키에서 단위 테스트는 아래와 같은 이유로 수행합니다.

- 리펙토링 내성: 리펙토링은 "기존 결과에 영향을 미치지 않고 코드의 로직을 개선하는 행위" 를 뜻합니다. 테스트가 없다면 리펙토링 후에 기존 결과에 영향을 미치지 않았는지 확인하기 위해 구현된 모든 로직들을 검토해야 합니다. 이는 리펙토링마다 생산성 저하를 의미하고 리펙토링을 멀리하게 되는 이유가 됩니다. 하지만 테스트 코드가 있다면 리펙토링 후에 전체 테스트를 실행해 보는 것만으로 기존 결과에 영향을 미치지 않았는지 검토할 수 있습니다.
- 남의 코드에 대한 신뢰성: 본인 의외에 다른 사람이 작성한 코드가 내가 생각한대로 100% 작동할 것이라고 확신하는건 쉽지 않습니다. 하지만 테스트 코드가 있다면 해당 테스트가 성공함을 확인함으로써 이 코드가 내가 생각한대로 작동한다는걸 확신할 후 있습니다.
- 남의 코드에 대한 빠른 이해: 내 코드 짤 시간도 부족한데 내 피쳐를 개발하기 위해 남이 짠 코드를 이해하겠다고 나의 소중한 시간을 할애하여 남의 코드를 해석하고 있는건 매우 비효율적 입니다. 하지만 테스트 코드가 있다면 이 코드가 어떤 분기에서 어떻게 다른 결과를 나타내는지 쉽게 파악할 수 있게 됩니다.
- 깨끗한 코드: 테스트를 안하게 된다면 Clean Code 의 조건 중 하나인 "testable 한 코드" 조건이 무시됩니다. 그러면 자연스럽게 Clean Code 와는 점점 멀어지게 됩니다.

### 테스트 코드 규칙

- 모든 테스트는 빠른 파악을 위해 테스트 클래스 위에 어떤 조건에서 성공하고 실패하는지를 주석으로 나타내야 합니다.

```kotlin
/**
 * 테스트 성공 조건
 * 1. 컴포저블 함수여야 함
 * 2. 컴포저블을 방출하는 역할이여야 함
 * 3. "List", "Map", "Set" 타입이 포함된 인자를 대상으로 경고해야 함 (MutableCollections)
 * 4. "Immutable", "Persistent" 타입이 포함된 인자는 경고하지 말아야 함 (ImmutableCollections)
 */
class PreferredImmutableCollectionsTest
```

- 테스트 함수 명명은 ~should, ~must,  ~can 과 같이 제안문이 아닌 ~is 같이 원하는 결과가 확정으로 들어나야 합니다. 테스트는 내가 원하는대로 잘 작동하는지를 확인하는 절차이므로 **제안이 아닌 확정**으로 네이밍 해야 합니다.

```kotlin
@Test
fun `Don't use Public at MutableCollection`() // 잘못된 명명

@Test
fun `Using MutableCollections as public throws an error`() // 올바른 명명
```

### 프레임워크

덕키는 [JUnit4](https://junit.org/junit4/) 와 [Mockk](https://github.com/mockk/mockk) 를 사용합니다. JUnit5 는 아직 공식 Gradle 지원이 없을 뿐더라, 덕키팀에서 메인으로 사용하는 Jetpack Compose 의 UI 테스트 경우에도 JUnit4 를 사용합니다. Mockk 는 코틀린으로 개발됐음으로 코틀린과의 친화성을 위해 채택하였습니다.

