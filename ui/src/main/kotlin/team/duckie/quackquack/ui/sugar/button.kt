// This file was automatically generated by sugar-processor.
// Do not modify it manually.
// @formatter:off
@file:Suppress("NoConsecutiveBlankLines", "PackageDirectoryMismatch", "Wrapping",
    "TrailingCommaOnCallSite", "ArgumentListWrapping", "RedundantVisibilityModifier",
    "UnusedImport", "NoUnusedImports", "SpacingAroundParens", "Indentation", "NoUnitReturn",
    "RedundantUnitReturnType", "ModifierParameter", "KDocUnresolvedReference", "NoTrailingSpaces",
    "NoMultipleSpaces", "ktlint")
@file:OptIn(SugarCompilerApi::class, SugarGeneratorUsage::class)
@file:SugarGeneratedFile

package team.duckie.quackquack.ui.sugar

import androidx.compose.runtime.Composable
import androidx.compose.runtime.NonRestartableComposable
import androidx.compose.ui.Modifier
import kotlin.Boolean
import kotlin.Function0
import kotlin.OptIn
import kotlin.String
import kotlin.Suppress
import kotlin.Unit
import team.duckie.quackquack.casa.`annotation`.Casa
import team.duckie.quackquack.casa.`annotation`.CasaValue
import team.duckie.quackquack.casa.`annotation`.SugarGeneratorUsage
import team.duckie.quackquack.sugar.material.SugarCompilerApi
import team.duckie.quackquack.sugar.material.SugarGeneratedFile
import team.duckie.quackquack.sugar.material.SugarRefer
import team.duckie.quackquack.sugar.material.sugar
import team.duckie.quackquack.ui.QuackButton
import team.duckie.quackquack.ui.QuackButtonStyle
import team.duckie.quackquack.ui.util.ExperimentalQuackQuackApi

/**
 * 버튼을 그립니다.
 *
 * - 이 컴포넌트는 자체의 패딩 정책을 구현합니다.
 * - 이 컴포넌트는 자체의 배치 정책을 구현합니다.
 * - [스타일][style]별로 사용 가능한 데코레이터가 달라집니다.
 *
 * ### 패딩 정책
 *
 * 1. [버튼의 스타일][QuackButtonStyle]에서 [contentPadding][QuackButtonStyle.contentPadding] 옵션을
 * 별도로 제공하고 있습니다. 이는 [Modifier.padding]과 다른 패딩 정책을 사용합니다. [Modifier.padding]은
 * 버튼의 루트 레이아웃을 기준으로 패딩이 적용되지만, [QuackButtonStyle.contentPadding]은 버튼의
 * 텍스트를 기준으로 패딩이 적용됩니다. 이 부분의 자세한 내용은 배치 정책 세션을 참고하세요.
 * 2. [LayoutModifier]를 사용하여 컴포넌트의 사이즈가 명시됐다면 [QuackButtonStyle.contentPadding]
 * 옵션은 무시됩니다. [contentPadding][QuackButtonStyle.contentPadding]은 컴포넌트 사이즈 하드코딩을
 * 대체하는 용도로 제공됩니다. 하지만 컴포넌트 사이즈가 하드코딩됐다면 [contentPadding][QuackButtonStyle.contentPadding]을
 * 제공하는 의미가 없어집니다. 따라서 컴포넌트의 사이즈가 하드코딩됐다면 개발자의 의도를 존중한다는 원칙하에
 * 컴포넌트의 사이즈가 중첩으로 확장되는 일을 예방하고자 [contentPadding][QuackButtonStyle.contentPadding]
 * 옵션을 무시합니다. 예를 들어 `Modifier.height(10.dp)`로 컴포넌트 높이를 명시했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(vertical=10.dp)`을 제공했다고 해봅시다. 이런 경우에는
 * [contentPadding][QuackButtonStyle.contentPadding]이
 * 무시되고 버튼의 높이가 10dp로 적용됩니다. 컴포넌트 사이즈를 명시하면서 패딩을 적용하고 싶다면
 * [contentPadding][QuackButtonStyle.contentPadding] 대신에 [Modifier.padding]을 사용하세요.
 * [LayoutModifier]를 사용하는 흔한 [Modifier]로는 [Modifier.size], [Modifier.height], [Modifier.width] 등이
 * 있습니다. [LayoutModifierNode]를 사용하는 [Modifier]는 [contentPadding][QuackButtonStyle.contentPadding] 무시
 * 옵션이 아직 지원되지 않습니다. ([#636](https://github.com/duckie-team/quack-quack-android/issues/636))
 *
 * ### 배치 정책
 *
 * [style.contentPadding][QuackButtonStyle.contentPadding]은 항상 버튼의 텍스트를 기준으로
 * 적용됩니다. 예를 들어 버튼의 아이콘을 leading과 trailing을 모두 제공했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(horizontal=10.dp)`를 제공했다면 양끝의 horizontal 패딩이 각각 아이콘을 기준으로
 * 적용되는 게 아닌 버튼의 텍스트를 기준으로 적용됩니다. 따라서 개발자는 [contentPadding][QuackButtonStyle.contentPadding]의 값을
 * 제공할 때 양끝 아이콘을 기준으로 제공하는 게 아닌 가운데 텍스트를 기준으로 제공해야 합니다.
 * 이 정책은 양끝 아이콘이 동적으로 적용될 때 의도하지 않는 버튼 사이즈 변경을 예방하기 위해
 * 고안됐습니다. 예를 들어 `contentPadding: QuackPadding(horizontal=10.dp)`을 양끝 아이콘 기준으로
 * 적용했다고 해봅시다. 처음에는 양끝에 아이콘이 없어서 가운데 텍스트를 기준으로 패딩이 적용됩니다.
 * 이 시점에는 버튼의 너비가 25dp입니다. (왼쪽 패딩 10dp, 텍스트 5dp, 오른쪽 패딩 10dp) 사용자
 * 요청에 의해 양쪽 모두에 5dp의 너비를 갖는 아이콘이 추가되었습니다. 이 시점에서는 양쪽 아이콘이
 * 존재하므로 [contentPadding][QuackButtonStyle.contentPadding]이 양쪽 아이콘을 기준으로 적용되어
 * 버튼의 너비가 35dp입니다. (왼쪽 패딩 10dp, 왼쪽 아이콘 5dp, 텍스트 5dp, 오른쪽 아이콘 5dp,
 * 오른쪽 패딩 10dp) 즉, 의도하지 않게 버튼의 너비가 10dp 증가하였습니다. 이러한 상황을 예방하기
 * 위해 이 정책이 사용됩니다.
 *
 * ### 사용 가능 데코레이터
 *
 * |                 style             | [icons][Modifier.icons] |                       description
 *                       |
 * | :-------------------------------: | :---------------------: |
 * :-----------------------------------------------------: |
 * |  [Large][QuackLargeButtonStyle]  |            ⭕           |                                    
 *                      |
 * | [Medium][QuackMediumButtonStyle] |            ⭕           |                                    
 *                      |
 * |  [Small][QuackSmallButtonStyle]  |            ❌           | 버튼의 너비가 좁기에 아이콘 데코레이터를 사용할 수 없습니다.
 * |
 *
 * This component uses [QuackButtonStyle.PrimaryLarge] as the token value for `style`.
 *
 * This document was automatically generated by [QuackButton].
 * If any contents are broken, please check the original document.
 *
 * @param enabled 활성화 상태 여부
 * @param text 중앙에 표시할 텍스트
 * @param rippleEnabled 클릭했을 때 리플 애니메이션을 적용할지 여부
 * @param onClick 클릭했을 때 실행할 람다식. [enabled]이 true일 때만 작동합니다.
 */
@Casa
@Composable
@NonRestartableComposable
@ExperimentalQuackQuackApi
@SugarRefer("team.duckie.quackquack.ui.QuackButton")
public fun QuackPrimaryLargeButton(
  modifier: Modifier = sugar(),
  enabled: Boolean = sugar(),
  @CasaValue("\"QuackButton is experimental\"") text: String,
  rippleEnabled: Boolean = sugar(),
  @CasaValue("{}") onClick: () -> Unit,
): Unit {
  QuackButton(
    modifier = modifier,
    enabled = enabled,
    style = QuackButtonStyle.PrimaryLarge,
    text = text,
    rippleEnabled = rippleEnabled,
    onClick = onClick,
  )
}

/**
 * 버튼을 그립니다.
 *
 * - 이 컴포넌트는 자체의 패딩 정책을 구현합니다.
 * - 이 컴포넌트는 자체의 배치 정책을 구현합니다.
 * - [스타일][style]별로 사용 가능한 데코레이터가 달라집니다.
 *
 * ### 패딩 정책
 *
 * 1. [버튼의 스타일][QuackButtonStyle]에서 [contentPadding][QuackButtonStyle.contentPadding] 옵션을
 * 별도로 제공하고 있습니다. 이는 [Modifier.padding]과 다른 패딩 정책을 사용합니다. [Modifier.padding]은
 * 버튼의 루트 레이아웃을 기준으로 패딩이 적용되지만, [QuackButtonStyle.contentPadding]은 버튼의
 * 텍스트를 기준으로 패딩이 적용됩니다. 이 부분의 자세한 내용은 배치 정책 세션을 참고하세요.
 * 2. [LayoutModifier]를 사용하여 컴포넌트의 사이즈가 명시됐다면 [QuackButtonStyle.contentPadding]
 * 옵션은 무시됩니다. [contentPadding][QuackButtonStyle.contentPadding]은 컴포넌트 사이즈 하드코딩을
 * 대체하는 용도로 제공됩니다. 하지만 컴포넌트 사이즈가 하드코딩됐다면 [contentPadding][QuackButtonStyle.contentPadding]을
 * 제공하는 의미가 없어집니다. 따라서 컴포넌트의 사이즈가 하드코딩됐다면 개발자의 의도를 존중한다는 원칙하에
 * 컴포넌트의 사이즈가 중첩으로 확장되는 일을 예방하고자 [contentPadding][QuackButtonStyle.contentPadding]
 * 옵션을 무시합니다. 예를 들어 `Modifier.height(10.dp)`로 컴포넌트 높이를 명시했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(vertical=10.dp)`을 제공했다고 해봅시다. 이런 경우에는
 * [contentPadding][QuackButtonStyle.contentPadding]이
 * 무시되고 버튼의 높이가 10dp로 적용됩니다. 컴포넌트 사이즈를 명시하면서 패딩을 적용하고 싶다면
 * [contentPadding][QuackButtonStyle.contentPadding] 대신에 [Modifier.padding]을 사용하세요.
 * [LayoutModifier]를 사용하는 흔한 [Modifier]로는 [Modifier.size], [Modifier.height], [Modifier.width] 등이
 * 있습니다. [LayoutModifierNode]를 사용하는 [Modifier]는 [contentPadding][QuackButtonStyle.contentPadding] 무시
 * 옵션이 아직 지원되지 않습니다. ([#636](https://github.com/duckie-team/quack-quack-android/issues/636))
 *
 * ### 배치 정책
 *
 * [style.contentPadding][QuackButtonStyle.contentPadding]은 항상 버튼의 텍스트를 기준으로
 * 적용됩니다. 예를 들어 버튼의 아이콘을 leading과 trailing을 모두 제공했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(horizontal=10.dp)`를 제공했다면 양끝의 horizontal 패딩이 각각 아이콘을 기준으로
 * 적용되는 게 아닌 버튼의 텍스트를 기준으로 적용됩니다. 따라서 개발자는 [contentPadding][QuackButtonStyle.contentPadding]의 값을
 * 제공할 때 양끝 아이콘을 기준으로 제공하는 게 아닌 가운데 텍스트를 기준으로 제공해야 합니다.
 * 이 정책은 양끝 아이콘이 동적으로 적용될 때 의도하지 않는 버튼 사이즈 변경을 예방하기 위해
 * 고안됐습니다. 예를 들어 `contentPadding: QuackPadding(horizontal=10.dp)`을 양끝 아이콘 기준으로
 * 적용했다고 해봅시다. 처음에는 양끝에 아이콘이 없어서 가운데 텍스트를 기준으로 패딩이 적용됩니다.
 * 이 시점에는 버튼의 너비가 25dp입니다. (왼쪽 패딩 10dp, 텍스트 5dp, 오른쪽 패딩 10dp) 사용자
 * 요청에 의해 양쪽 모두에 5dp의 너비를 갖는 아이콘이 추가되었습니다. 이 시점에서는 양쪽 아이콘이
 * 존재하므로 [contentPadding][QuackButtonStyle.contentPadding]이 양쪽 아이콘을 기준으로 적용되어
 * 버튼의 너비가 35dp입니다. (왼쪽 패딩 10dp, 왼쪽 아이콘 5dp, 텍스트 5dp, 오른쪽 아이콘 5dp,
 * 오른쪽 패딩 10dp) 즉, 의도하지 않게 버튼의 너비가 10dp 증가하였습니다. 이러한 상황을 예방하기
 * 위해 이 정책이 사용됩니다.
 *
 * ### 사용 가능 데코레이터
 *
 * |                 style             | [icons][Modifier.icons] |                       description
 *                       |
 * | :-------------------------------: | :---------------------: |
 * :-----------------------------------------------------: |
 * |  [Large][QuackLargeButtonStyle]  |            ⭕           |                                    
 *                      |
 * | [Medium][QuackMediumButtonStyle] |            ⭕           |                                    
 *                      |
 * |  [Small][QuackSmallButtonStyle]  |            ❌           | 버튼의 너비가 좁기에 아이콘 데코레이터를 사용할 수 없습니다.
 * |
 *
 * This component uses [QuackButtonStyle.SecondaryLarge] as the token value for `style`.
 *
 * This document was automatically generated by [QuackButton].
 * If any contents are broken, please check the original document.
 *
 * @param enabled 활성화 상태 여부
 * @param text 중앙에 표시할 텍스트
 * @param rippleEnabled 클릭했을 때 리플 애니메이션을 적용할지 여부
 * @param onClick 클릭했을 때 실행할 람다식. [enabled]이 true일 때만 작동합니다.
 */
@Casa
@Composable
@NonRestartableComposable
@ExperimentalQuackQuackApi
@SugarRefer("team.duckie.quackquack.ui.QuackButton")
public fun QuackSecondaryLargeButton(
  modifier: Modifier = sugar(),
  enabled: Boolean = sugar(),
  @CasaValue("\"QuackButton is experimental\"") text: String,
  rippleEnabled: Boolean = sugar(),
  @CasaValue("{}") onClick: () -> Unit,
): Unit {
  QuackButton(
    modifier = modifier,
    enabled = enabled,
    style = QuackButtonStyle.SecondaryLarge,
    text = text,
    rippleEnabled = rippleEnabled,
    onClick = onClick,
  )
}

/**
 * 버튼을 그립니다.
 *
 * - 이 컴포넌트는 자체의 패딩 정책을 구현합니다.
 * - 이 컴포넌트는 자체의 배치 정책을 구현합니다.
 * - [스타일][style]별로 사용 가능한 데코레이터가 달라집니다.
 *
 * ### 패딩 정책
 *
 * 1. [버튼의 스타일][QuackButtonStyle]에서 [contentPadding][QuackButtonStyle.contentPadding] 옵션을
 * 별도로 제공하고 있습니다. 이는 [Modifier.padding]과 다른 패딩 정책을 사용합니다. [Modifier.padding]은
 * 버튼의 루트 레이아웃을 기준으로 패딩이 적용되지만, [QuackButtonStyle.contentPadding]은 버튼의
 * 텍스트를 기준으로 패딩이 적용됩니다. 이 부분의 자세한 내용은 배치 정책 세션을 참고하세요.
 * 2. [LayoutModifier]를 사용하여 컴포넌트의 사이즈가 명시됐다면 [QuackButtonStyle.contentPadding]
 * 옵션은 무시됩니다. [contentPadding][QuackButtonStyle.contentPadding]은 컴포넌트 사이즈 하드코딩을
 * 대체하는 용도로 제공됩니다. 하지만 컴포넌트 사이즈가 하드코딩됐다면 [contentPadding][QuackButtonStyle.contentPadding]을
 * 제공하는 의미가 없어집니다. 따라서 컴포넌트의 사이즈가 하드코딩됐다면 개발자의 의도를 존중한다는 원칙하에
 * 컴포넌트의 사이즈가 중첩으로 확장되는 일을 예방하고자 [contentPadding][QuackButtonStyle.contentPadding]
 * 옵션을 무시합니다. 예를 들어 `Modifier.height(10.dp)`로 컴포넌트 높이를 명시했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(vertical=10.dp)`을 제공했다고 해봅시다. 이런 경우에는
 * [contentPadding][QuackButtonStyle.contentPadding]이
 * 무시되고 버튼의 높이가 10dp로 적용됩니다. 컴포넌트 사이즈를 명시하면서 패딩을 적용하고 싶다면
 * [contentPadding][QuackButtonStyle.contentPadding] 대신에 [Modifier.padding]을 사용하세요.
 * [LayoutModifier]를 사용하는 흔한 [Modifier]로는 [Modifier.size], [Modifier.height], [Modifier.width] 등이
 * 있습니다. [LayoutModifierNode]를 사용하는 [Modifier]는 [contentPadding][QuackButtonStyle.contentPadding] 무시
 * 옵션이 아직 지원되지 않습니다. ([#636](https://github.com/duckie-team/quack-quack-android/issues/636))
 *
 * ### 배치 정책
 *
 * [style.contentPadding][QuackButtonStyle.contentPadding]은 항상 버튼의 텍스트를 기준으로
 * 적용됩니다. 예를 들어 버튼의 아이콘을 leading과 trailing을 모두 제공했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(horizontal=10.dp)`를 제공했다면 양끝의 horizontal 패딩이 각각 아이콘을 기준으로
 * 적용되는 게 아닌 버튼의 텍스트를 기준으로 적용됩니다. 따라서 개발자는 [contentPadding][QuackButtonStyle.contentPadding]의 값을
 * 제공할 때 양끝 아이콘을 기준으로 제공하는 게 아닌 가운데 텍스트를 기준으로 제공해야 합니다.
 * 이 정책은 양끝 아이콘이 동적으로 적용될 때 의도하지 않는 버튼 사이즈 변경을 예방하기 위해
 * 고안됐습니다. 예를 들어 `contentPadding: QuackPadding(horizontal=10.dp)`을 양끝 아이콘 기준으로
 * 적용했다고 해봅시다. 처음에는 양끝에 아이콘이 없어서 가운데 텍스트를 기준으로 패딩이 적용됩니다.
 * 이 시점에는 버튼의 너비가 25dp입니다. (왼쪽 패딩 10dp, 텍스트 5dp, 오른쪽 패딩 10dp) 사용자
 * 요청에 의해 양쪽 모두에 5dp의 너비를 갖는 아이콘이 추가되었습니다. 이 시점에서는 양쪽 아이콘이
 * 존재하므로 [contentPadding][QuackButtonStyle.contentPadding]이 양쪽 아이콘을 기준으로 적용되어
 * 버튼의 너비가 35dp입니다. (왼쪽 패딩 10dp, 왼쪽 아이콘 5dp, 텍스트 5dp, 오른쪽 아이콘 5dp,
 * 오른쪽 패딩 10dp) 즉, 의도하지 않게 버튼의 너비가 10dp 증가하였습니다. 이러한 상황을 예방하기
 * 위해 이 정책이 사용됩니다.
 *
 * ### 사용 가능 데코레이터
 *
 * |                 style             | [icons][Modifier.icons] |                       description
 *                       |
 * | :-------------------------------: | :---------------------: |
 * :-----------------------------------------------------: |
 * |  [Large][QuackLargeButtonStyle]  |            ⭕           |                                    
 *                      |
 * | [Medium][QuackMediumButtonStyle] |            ⭕           |                                    
 *                      |
 * |  [Small][QuackSmallButtonStyle]  |            ❌           | 버튼의 너비가 좁기에 아이콘 데코레이터를 사용할 수 없습니다.
 * |
 *
 * This component uses [QuackButtonStyle.Medium] as the token value for `style`.
 *
 * This document was automatically generated by [QuackButton].
 * If any contents are broken, please check the original document.
 *
 * @param enabled 활성화 상태 여부
 * @param text 중앙에 표시할 텍스트
 * @param rippleEnabled 클릭했을 때 리플 애니메이션을 적용할지 여부
 * @param onClick 클릭했을 때 실행할 람다식. [enabled]이 true일 때만 작동합니다.
 */
@Casa
@Composable
@NonRestartableComposable
@ExperimentalQuackQuackApi
@SugarRefer("team.duckie.quackquack.ui.QuackButton")
public fun QuackMediumButton(
  modifier: Modifier = sugar(),
  enabled: Boolean = sugar(),
  @CasaValue("\"QuackButton is experimental\"") text: String,
  rippleEnabled: Boolean = sugar(),
  @CasaValue("{}") onClick: () -> Unit,
): Unit {
  QuackButton(
    modifier = modifier,
    enabled = enabled,
    style = QuackButtonStyle.Medium,
    text = text,
    rippleEnabled = rippleEnabled,
    onClick = onClick,
  )
}

/**
 * 버튼을 그립니다.
 *
 * - 이 컴포넌트는 자체의 패딩 정책을 구현합니다.
 * - 이 컴포넌트는 자체의 배치 정책을 구현합니다.
 * - [스타일][style]별로 사용 가능한 데코레이터가 달라집니다.
 *
 * ### 패딩 정책
 *
 * 1. [버튼의 스타일][QuackButtonStyle]에서 [contentPadding][QuackButtonStyle.contentPadding] 옵션을
 * 별도로 제공하고 있습니다. 이는 [Modifier.padding]과 다른 패딩 정책을 사용합니다. [Modifier.padding]은
 * 버튼의 루트 레이아웃을 기준으로 패딩이 적용되지만, [QuackButtonStyle.contentPadding]은 버튼의
 * 텍스트를 기준으로 패딩이 적용됩니다. 이 부분의 자세한 내용은 배치 정책 세션을 참고하세요.
 * 2. [LayoutModifier]를 사용하여 컴포넌트의 사이즈가 명시됐다면 [QuackButtonStyle.contentPadding]
 * 옵션은 무시됩니다. [contentPadding][QuackButtonStyle.contentPadding]은 컴포넌트 사이즈 하드코딩을
 * 대체하는 용도로 제공됩니다. 하지만 컴포넌트 사이즈가 하드코딩됐다면 [contentPadding][QuackButtonStyle.contentPadding]을
 * 제공하는 의미가 없어집니다. 따라서 컴포넌트의 사이즈가 하드코딩됐다면 개발자의 의도를 존중한다는 원칙하에
 * 컴포넌트의 사이즈가 중첩으로 확장되는 일을 예방하고자 [contentPadding][QuackButtonStyle.contentPadding]
 * 옵션을 무시합니다. 예를 들어 `Modifier.height(10.dp)`로 컴포넌트 높이를 명시했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(vertical=10.dp)`을 제공했다고 해봅시다. 이런 경우에는
 * [contentPadding][QuackButtonStyle.contentPadding]이
 * 무시되고 버튼의 높이가 10dp로 적용됩니다. 컴포넌트 사이즈를 명시하면서 패딩을 적용하고 싶다면
 * [contentPadding][QuackButtonStyle.contentPadding] 대신에 [Modifier.padding]을 사용하세요.
 * [LayoutModifier]를 사용하는 흔한 [Modifier]로는 [Modifier.size], [Modifier.height], [Modifier.width] 등이
 * 있습니다. [LayoutModifierNode]를 사용하는 [Modifier]는 [contentPadding][QuackButtonStyle.contentPadding] 무시
 * 옵션이 아직 지원되지 않습니다. ([#636](https://github.com/duckie-team/quack-quack-android/issues/636))
 *
 * ### 배치 정책
 *
 * [style.contentPadding][QuackButtonStyle.contentPadding]은 항상 버튼의 텍스트를 기준으로
 * 적용됩니다. 예를 들어 버튼의 아이콘을 leading과 trailing을 모두 제공했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(horizontal=10.dp)`를 제공했다면 양끝의 horizontal 패딩이 각각 아이콘을 기준으로
 * 적용되는 게 아닌 버튼의 텍스트를 기준으로 적용됩니다. 따라서 개발자는 [contentPadding][QuackButtonStyle.contentPadding]의 값을
 * 제공할 때 양끝 아이콘을 기준으로 제공하는 게 아닌 가운데 텍스트를 기준으로 제공해야 합니다.
 * 이 정책은 양끝 아이콘이 동적으로 적용될 때 의도하지 않는 버튼 사이즈 변경을 예방하기 위해
 * 고안됐습니다. 예를 들어 `contentPadding: QuackPadding(horizontal=10.dp)`을 양끝 아이콘 기준으로
 * 적용했다고 해봅시다. 처음에는 양끝에 아이콘이 없어서 가운데 텍스트를 기준으로 패딩이 적용됩니다.
 * 이 시점에는 버튼의 너비가 25dp입니다. (왼쪽 패딩 10dp, 텍스트 5dp, 오른쪽 패딩 10dp) 사용자
 * 요청에 의해 양쪽 모두에 5dp의 너비를 갖는 아이콘이 추가되었습니다. 이 시점에서는 양쪽 아이콘이
 * 존재하므로 [contentPadding][QuackButtonStyle.contentPadding]이 양쪽 아이콘을 기준으로 적용되어
 * 버튼의 너비가 35dp입니다. (왼쪽 패딩 10dp, 왼쪽 아이콘 5dp, 텍스트 5dp, 오른쪽 아이콘 5dp,
 * 오른쪽 패딩 10dp) 즉, 의도하지 않게 버튼의 너비가 10dp 증가하였습니다. 이러한 상황을 예방하기
 * 위해 이 정책이 사용됩니다.
 *
 * ### 사용 가능 데코레이터
 *
 * |                 style             | [icons][Modifier.icons] |                       description
 *                       |
 * | :-------------------------------: | :---------------------: |
 * :-----------------------------------------------------: |
 * |  [Large][QuackLargeButtonStyle]  |            ⭕           |                                    
 *                      |
 * | [Medium][QuackMediumButtonStyle] |            ⭕           |                                    
 *                      |
 * |  [Small][QuackSmallButtonStyle]  |            ❌           | 버튼의 너비가 좁기에 아이콘 데코레이터를 사용할 수 없습니다.
 * |
 *
 * This component uses [QuackButtonStyle.PrimaryFilledSmall] as the token value for `style`.
 *
 * This document was automatically generated by [QuackButton].
 * If any contents are broken, please check the original document.
 *
 * @param enabled 활성화 상태 여부
 * @param text 중앙에 표시할 텍스트
 * @param rippleEnabled 클릭했을 때 리플 애니메이션을 적용할지 여부
 * @param onClick 클릭했을 때 실행할 람다식. [enabled]이 true일 때만 작동합니다.
 */
@Casa
@Composable
@NonRestartableComposable
@ExperimentalQuackQuackApi
@SugarRefer("team.duckie.quackquack.ui.QuackButton")
public fun QuackPrimaryFilledSmallButton(
  modifier: Modifier = sugar(),
  enabled: Boolean = sugar(),
  @CasaValue("\"QuackButton is experimental\"") text: String,
  rippleEnabled: Boolean = sugar(),
  @CasaValue("{}") onClick: () -> Unit,
): Unit {
  QuackButton(
    modifier = modifier,
    enabled = enabled,
    style = QuackButtonStyle.PrimaryFilledSmall,
    text = text,
    rippleEnabled = rippleEnabled,
    onClick = onClick,
  )
}

/**
 * 버튼을 그립니다.
 *
 * - 이 컴포넌트는 자체의 패딩 정책을 구현합니다.
 * - 이 컴포넌트는 자체의 배치 정책을 구현합니다.
 * - [스타일][style]별로 사용 가능한 데코레이터가 달라집니다.
 *
 * ### 패딩 정책
 *
 * 1. [버튼의 스타일][QuackButtonStyle]에서 [contentPadding][QuackButtonStyle.contentPadding] 옵션을
 * 별도로 제공하고 있습니다. 이는 [Modifier.padding]과 다른 패딩 정책을 사용합니다. [Modifier.padding]은
 * 버튼의 루트 레이아웃을 기준으로 패딩이 적용되지만, [QuackButtonStyle.contentPadding]은 버튼의
 * 텍스트를 기준으로 패딩이 적용됩니다. 이 부분의 자세한 내용은 배치 정책 세션을 참고하세요.
 * 2. [LayoutModifier]를 사용하여 컴포넌트의 사이즈가 명시됐다면 [QuackButtonStyle.contentPadding]
 * 옵션은 무시됩니다. [contentPadding][QuackButtonStyle.contentPadding]은 컴포넌트 사이즈 하드코딩을
 * 대체하는 용도로 제공됩니다. 하지만 컴포넌트 사이즈가 하드코딩됐다면 [contentPadding][QuackButtonStyle.contentPadding]을
 * 제공하는 의미가 없어집니다. 따라서 컴포넌트의 사이즈가 하드코딩됐다면 개발자의 의도를 존중한다는 원칙하에
 * 컴포넌트의 사이즈가 중첩으로 확장되는 일을 예방하고자 [contentPadding][QuackButtonStyle.contentPadding]
 * 옵션을 무시합니다. 예를 들어 `Modifier.height(10.dp)`로 컴포넌트 높이를 명시했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(vertical=10.dp)`을 제공했다고 해봅시다. 이런 경우에는
 * [contentPadding][QuackButtonStyle.contentPadding]이
 * 무시되고 버튼의 높이가 10dp로 적용됩니다. 컴포넌트 사이즈를 명시하면서 패딩을 적용하고 싶다면
 * [contentPadding][QuackButtonStyle.contentPadding] 대신에 [Modifier.padding]을 사용하세요.
 * [LayoutModifier]를 사용하는 흔한 [Modifier]로는 [Modifier.size], [Modifier.height], [Modifier.width] 등이
 * 있습니다. [LayoutModifierNode]를 사용하는 [Modifier]는 [contentPadding][QuackButtonStyle.contentPadding] 무시
 * 옵션이 아직 지원되지 않습니다. ([#636](https://github.com/duckie-team/quack-quack-android/issues/636))
 *
 * ### 배치 정책
 *
 * [style.contentPadding][QuackButtonStyle.contentPadding]은 항상 버튼의 텍스트를 기준으로
 * 적용됩니다. 예를 들어 버튼의 아이콘을 leading과 trailing을 모두 제공했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(horizontal=10.dp)`를 제공했다면 양끝의 horizontal 패딩이 각각 아이콘을 기준으로
 * 적용되는 게 아닌 버튼의 텍스트를 기준으로 적용됩니다. 따라서 개발자는 [contentPadding][QuackButtonStyle.contentPadding]의 값을
 * 제공할 때 양끝 아이콘을 기준으로 제공하는 게 아닌 가운데 텍스트를 기준으로 제공해야 합니다.
 * 이 정책은 양끝 아이콘이 동적으로 적용될 때 의도하지 않는 버튼 사이즈 변경을 예방하기 위해
 * 고안됐습니다. 예를 들어 `contentPadding: QuackPadding(horizontal=10.dp)`을 양끝 아이콘 기준으로
 * 적용했다고 해봅시다. 처음에는 양끝에 아이콘이 없어서 가운데 텍스트를 기준으로 패딩이 적용됩니다.
 * 이 시점에는 버튼의 너비가 25dp입니다. (왼쪽 패딩 10dp, 텍스트 5dp, 오른쪽 패딩 10dp) 사용자
 * 요청에 의해 양쪽 모두에 5dp의 너비를 갖는 아이콘이 추가되었습니다. 이 시점에서는 양쪽 아이콘이
 * 존재하므로 [contentPadding][QuackButtonStyle.contentPadding]이 양쪽 아이콘을 기준으로 적용되어
 * 버튼의 너비가 35dp입니다. (왼쪽 패딩 10dp, 왼쪽 아이콘 5dp, 텍스트 5dp, 오른쪽 아이콘 5dp,
 * 오른쪽 패딩 10dp) 즉, 의도하지 않게 버튼의 너비가 10dp 증가하였습니다. 이러한 상황을 예방하기
 * 위해 이 정책이 사용됩니다.
 *
 * ### 사용 가능 데코레이터
 *
 * |                 style             | [icons][Modifier.icons] |                       description
 *                       |
 * | :-------------------------------: | :---------------------: |
 * :-----------------------------------------------------: |
 * |  [Large][QuackLargeButtonStyle]  |            ⭕           |                                    
 *                      |
 * | [Medium][QuackMediumButtonStyle] |            ⭕           |                                    
 *                      |
 * |  [Small][QuackSmallButtonStyle]  |            ❌           | 버튼의 너비가 좁기에 아이콘 데코레이터를 사용할 수 없습니다.
 * |
 *
 * This component uses [QuackButtonStyle.PrimaryOutlinedSmall] as the token value for `style`.
 *
 * This document was automatically generated by [QuackButton].
 * If any contents are broken, please check the original document.
 *
 * @param enabled 활성화 상태 여부
 * @param text 중앙에 표시할 텍스트
 * @param rippleEnabled 클릭했을 때 리플 애니메이션을 적용할지 여부
 * @param onClick 클릭했을 때 실행할 람다식. [enabled]이 true일 때만 작동합니다.
 */
@Casa
@Composable
@NonRestartableComposable
@ExperimentalQuackQuackApi
@SugarRefer("team.duckie.quackquack.ui.QuackButton")
public fun QuackPrimaryOutlinedSmallButton(
  modifier: Modifier = sugar(),
  enabled: Boolean = sugar(),
  @CasaValue("\"QuackButton is experimental\"") text: String,
  rippleEnabled: Boolean = sugar(),
  @CasaValue("{}") onClick: () -> Unit,
): Unit {
  QuackButton(
    modifier = modifier,
    enabled = enabled,
    style = QuackButtonStyle.PrimaryOutlinedSmall,
    text = text,
    rippleEnabled = rippleEnabled,
    onClick = onClick,
  )
}

/**
 * 버튼을 그립니다.
 *
 * - 이 컴포넌트는 자체의 패딩 정책을 구현합니다.
 * - 이 컴포넌트는 자체의 배치 정책을 구현합니다.
 * - [스타일][style]별로 사용 가능한 데코레이터가 달라집니다.
 *
 * ### 패딩 정책
 *
 * 1. [버튼의 스타일][QuackButtonStyle]에서 [contentPadding][QuackButtonStyle.contentPadding] 옵션을
 * 별도로 제공하고 있습니다. 이는 [Modifier.padding]과 다른 패딩 정책을 사용합니다. [Modifier.padding]은
 * 버튼의 루트 레이아웃을 기준으로 패딩이 적용되지만, [QuackButtonStyle.contentPadding]은 버튼의
 * 텍스트를 기준으로 패딩이 적용됩니다. 이 부분의 자세한 내용은 배치 정책 세션을 참고하세요.
 * 2. [LayoutModifier]를 사용하여 컴포넌트의 사이즈가 명시됐다면 [QuackButtonStyle.contentPadding]
 * 옵션은 무시됩니다. [contentPadding][QuackButtonStyle.contentPadding]은 컴포넌트 사이즈 하드코딩을
 * 대체하는 용도로 제공됩니다. 하지만 컴포넌트 사이즈가 하드코딩됐다면 [contentPadding][QuackButtonStyle.contentPadding]을
 * 제공하는 의미가 없어집니다. 따라서 컴포넌트의 사이즈가 하드코딩됐다면 개발자의 의도를 존중한다는 원칙하에
 * 컴포넌트의 사이즈가 중첩으로 확장되는 일을 예방하고자 [contentPadding][QuackButtonStyle.contentPadding]
 * 옵션을 무시합니다. 예를 들어 `Modifier.height(10.dp)`로 컴포넌트 높이를 명시했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(vertical=10.dp)`을 제공했다고 해봅시다. 이런 경우에는
 * [contentPadding][QuackButtonStyle.contentPadding]이
 * 무시되고 버튼의 높이가 10dp로 적용됩니다. 컴포넌트 사이즈를 명시하면서 패딩을 적용하고 싶다면
 * [contentPadding][QuackButtonStyle.contentPadding] 대신에 [Modifier.padding]을 사용하세요.
 * [LayoutModifier]를 사용하는 흔한 [Modifier]로는 [Modifier.size], [Modifier.height], [Modifier.width] 등이
 * 있습니다. [LayoutModifierNode]를 사용하는 [Modifier]는 [contentPadding][QuackButtonStyle.contentPadding] 무시
 * 옵션이 아직 지원되지 않습니다. ([#636](https://github.com/duckie-team/quack-quack-android/issues/636))
 *
 * ### 배치 정책
 *
 * [style.contentPadding][QuackButtonStyle.contentPadding]은 항상 버튼의 텍스트를 기준으로
 * 적용됩니다. 예를 들어 버튼의 아이콘을 leading과 trailing을 모두 제공했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(horizontal=10.dp)`를 제공했다면 양끝의 horizontal 패딩이 각각 아이콘을 기준으로
 * 적용되는 게 아닌 버튼의 텍스트를 기준으로 적용됩니다. 따라서 개발자는 [contentPadding][QuackButtonStyle.contentPadding]의 값을
 * 제공할 때 양끝 아이콘을 기준으로 제공하는 게 아닌 가운데 텍스트를 기준으로 제공해야 합니다.
 * 이 정책은 양끝 아이콘이 동적으로 적용될 때 의도하지 않는 버튼 사이즈 변경을 예방하기 위해
 * 고안됐습니다. 예를 들어 `contentPadding: QuackPadding(horizontal=10.dp)`을 양끝 아이콘 기준으로
 * 적용했다고 해봅시다. 처음에는 양끝에 아이콘이 없어서 가운데 텍스트를 기준으로 패딩이 적용됩니다.
 * 이 시점에는 버튼의 너비가 25dp입니다. (왼쪽 패딩 10dp, 텍스트 5dp, 오른쪽 패딩 10dp) 사용자
 * 요청에 의해 양쪽 모두에 5dp의 너비를 갖는 아이콘이 추가되었습니다. 이 시점에서는 양쪽 아이콘이
 * 존재하므로 [contentPadding][QuackButtonStyle.contentPadding]이 양쪽 아이콘을 기준으로 적용되어
 * 버튼의 너비가 35dp입니다. (왼쪽 패딩 10dp, 왼쪽 아이콘 5dp, 텍스트 5dp, 오른쪽 아이콘 5dp,
 * 오른쪽 패딩 10dp) 즉, 의도하지 않게 버튼의 너비가 10dp 증가하였습니다. 이러한 상황을 예방하기
 * 위해 이 정책이 사용됩니다.
 *
 * ### 사용 가능 데코레이터
 *
 * |                 style             | [icons][Modifier.icons] |                       description
 *                       |
 * | :-------------------------------: | :---------------------: |
 * :-----------------------------------------------------: |
 * |  [Large][QuackLargeButtonStyle]  |            ⭕           |                                    
 *                      |
 * | [Medium][QuackMediumButtonStyle] |            ⭕           |                                    
 *                      |
 * |  [Small][QuackSmallButtonStyle]  |            ❌           | 버튼의 너비가 좁기에 아이콘 데코레이터를 사용할 수 없습니다.
 * |
 *
 * This component uses [QuackButtonStyle.PrimaryOutlinedRoundSmall] as the token value for `style`.
 *
 * This document was automatically generated by [QuackButton].
 * If any contents are broken, please check the original document.
 *
 * @param enabled 활성화 상태 여부
 * @param text 중앙에 표시할 텍스트
 * @param rippleEnabled 클릭했을 때 리플 애니메이션을 적용할지 여부
 * @param onClick 클릭했을 때 실행할 람다식. [enabled]이 true일 때만 작동합니다.
 */
@Casa
@Composable
@NonRestartableComposable
@ExperimentalQuackQuackApi
@SugarRefer("team.duckie.quackquack.ui.QuackButton")
public fun QuackPrimaryOutlinedRoundSmallButton(
  modifier: Modifier = sugar(),
  enabled: Boolean = sugar(),
  @CasaValue("\"QuackButton is experimental\"") text: String,
  rippleEnabled: Boolean = sugar(),
  @CasaValue("{}") onClick: () -> Unit,
): Unit {
  QuackButton(
    modifier = modifier,
    enabled = enabled,
    style = QuackButtonStyle.PrimaryOutlinedRoundSmall,
    text = text,
    rippleEnabled = rippleEnabled,
    onClick = onClick,
  )
}

/**
 * 버튼을 그립니다.
 *
 * - 이 컴포넌트는 자체의 패딩 정책을 구현합니다.
 * - 이 컴포넌트는 자체의 배치 정책을 구현합니다.
 * - [스타일][style]별로 사용 가능한 데코레이터가 달라집니다.
 *
 * ### 패딩 정책
 *
 * 1. [버튼의 스타일][QuackButtonStyle]에서 [contentPadding][QuackButtonStyle.contentPadding] 옵션을
 * 별도로 제공하고 있습니다. 이는 [Modifier.padding]과 다른 패딩 정책을 사용합니다. [Modifier.padding]은
 * 버튼의 루트 레이아웃을 기준으로 패딩이 적용되지만, [QuackButtonStyle.contentPadding]은 버튼의
 * 텍스트를 기준으로 패딩이 적용됩니다. 이 부분의 자세한 내용은 배치 정책 세션을 참고하세요.
 * 2. [LayoutModifier]를 사용하여 컴포넌트의 사이즈가 명시됐다면 [QuackButtonStyle.contentPadding]
 * 옵션은 무시됩니다. [contentPadding][QuackButtonStyle.contentPadding]은 컴포넌트 사이즈 하드코딩을
 * 대체하는 용도로 제공됩니다. 하지만 컴포넌트 사이즈가 하드코딩됐다면 [contentPadding][QuackButtonStyle.contentPadding]을
 * 제공하는 의미가 없어집니다. 따라서 컴포넌트의 사이즈가 하드코딩됐다면 개발자의 의도를 존중한다는 원칙하에
 * 컴포넌트의 사이즈가 중첩으로 확장되는 일을 예방하고자 [contentPadding][QuackButtonStyle.contentPadding]
 * 옵션을 무시합니다. 예를 들어 `Modifier.height(10.dp)`로 컴포넌트 높이를 명시했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(vertical=10.dp)`을 제공했다고 해봅시다. 이런 경우에는
 * [contentPadding][QuackButtonStyle.contentPadding]이
 * 무시되고 버튼의 높이가 10dp로 적용됩니다. 컴포넌트 사이즈를 명시하면서 패딩을 적용하고 싶다면
 * [contentPadding][QuackButtonStyle.contentPadding] 대신에 [Modifier.padding]을 사용하세요.
 * [LayoutModifier]를 사용하는 흔한 [Modifier]로는 [Modifier.size], [Modifier.height], [Modifier.width] 등이
 * 있습니다. [LayoutModifierNode]를 사용하는 [Modifier]는 [contentPadding][QuackButtonStyle.contentPadding] 무시
 * 옵션이 아직 지원되지 않습니다. ([#636](https://github.com/duckie-team/quack-quack-android/issues/636))
 *
 * ### 배치 정책
 *
 * [style.contentPadding][QuackButtonStyle.contentPadding]은 항상 버튼의 텍스트를 기준으로
 * 적용됩니다. 예를 들어 버튼의 아이콘을 leading과 trailing을 모두 제공했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(horizontal=10.dp)`를 제공했다면 양끝의 horizontal 패딩이 각각 아이콘을 기준으로
 * 적용되는 게 아닌 버튼의 텍스트를 기준으로 적용됩니다. 따라서 개발자는 [contentPadding][QuackButtonStyle.contentPadding]의 값을
 * 제공할 때 양끝 아이콘을 기준으로 제공하는 게 아닌 가운데 텍스트를 기준으로 제공해야 합니다.
 * 이 정책은 양끝 아이콘이 동적으로 적용될 때 의도하지 않는 버튼 사이즈 변경을 예방하기 위해
 * 고안됐습니다. 예를 들어 `contentPadding: QuackPadding(horizontal=10.dp)`을 양끝 아이콘 기준으로
 * 적용했다고 해봅시다. 처음에는 양끝에 아이콘이 없어서 가운데 텍스트를 기준으로 패딩이 적용됩니다.
 * 이 시점에는 버튼의 너비가 25dp입니다. (왼쪽 패딩 10dp, 텍스트 5dp, 오른쪽 패딩 10dp) 사용자
 * 요청에 의해 양쪽 모두에 5dp의 너비를 갖는 아이콘이 추가되었습니다. 이 시점에서는 양쪽 아이콘이
 * 존재하므로 [contentPadding][QuackButtonStyle.contentPadding]이 양쪽 아이콘을 기준으로 적용되어
 * 버튼의 너비가 35dp입니다. (왼쪽 패딩 10dp, 왼쪽 아이콘 5dp, 텍스트 5dp, 오른쪽 아이콘 5dp,
 * 오른쪽 패딩 10dp) 즉, 의도하지 않게 버튼의 너비가 10dp 증가하였습니다. 이러한 상황을 예방하기
 * 위해 이 정책이 사용됩니다.
 *
 * ### 사용 가능 데코레이터
 *
 * |                 style             | [icons][Modifier.icons] |                       description
 *                       |
 * | :-------------------------------: | :---------------------: |
 * :-----------------------------------------------------: |
 * |  [Large][QuackLargeButtonStyle]  |            ⭕           |                                    
 *                      |
 * | [Medium][QuackMediumButtonStyle] |            ⭕           |                                    
 *                      |
 * |  [Small][QuackSmallButtonStyle]  |            ❌           | 버튼의 너비가 좁기에 아이콘 데코레이터를 사용할 수 없습니다.
 * |
 *
 * This component uses [QuackButtonStyle.SecondarySmall] as the token value for `style`.
 *
 * This document was automatically generated by [QuackButton].
 * If any contents are broken, please check the original document.
 *
 * @param enabled 활성화 상태 여부
 * @param text 중앙에 표시할 텍스트
 * @param rippleEnabled 클릭했을 때 리플 애니메이션을 적용할지 여부
 * @param onClick 클릭했을 때 실행할 람다식. [enabled]이 true일 때만 작동합니다.
 */
@Casa
@Composable
@NonRestartableComposable
@ExperimentalQuackQuackApi
@SugarRefer("team.duckie.quackquack.ui.QuackButton")
public fun QuackSecondarySmallButton(
  modifier: Modifier = sugar(),
  enabled: Boolean = sugar(),
  @CasaValue("\"QuackButton is experimental\"") text: String,
  rippleEnabled: Boolean = sugar(),
  @CasaValue("{}") onClick: () -> Unit,
): Unit {
  QuackButton(
    modifier = modifier,
    enabled = enabled,
    style = QuackButtonStyle.SecondarySmall,
    text = text,
    rippleEnabled = rippleEnabled,
    onClick = onClick,
  )
}

/**
 * 버튼을 그립니다.
 *
 * - 이 컴포넌트는 자체의 패딩 정책을 구현합니다.
 * - 이 컴포넌트는 자체의 배치 정책을 구현합니다.
 * - [스타일][style]별로 사용 가능한 데코레이터가 달라집니다.
 *
 * ### 패딩 정책
 *
 * 1. [버튼의 스타일][QuackButtonStyle]에서 [contentPadding][QuackButtonStyle.contentPadding] 옵션을
 * 별도로 제공하고 있습니다. 이는 [Modifier.padding]과 다른 패딩 정책을 사용합니다. [Modifier.padding]은
 * 버튼의 루트 레이아웃을 기준으로 패딩이 적용되지만, [QuackButtonStyle.contentPadding]은 버튼의
 * 텍스트를 기준으로 패딩이 적용됩니다. 이 부분의 자세한 내용은 배치 정책 세션을 참고하세요.
 * 2. [LayoutModifier]를 사용하여 컴포넌트의 사이즈가 명시됐다면 [QuackButtonStyle.contentPadding]
 * 옵션은 무시됩니다. [contentPadding][QuackButtonStyle.contentPadding]은 컴포넌트 사이즈 하드코딩을
 * 대체하는 용도로 제공됩니다. 하지만 컴포넌트 사이즈가 하드코딩됐다면 [contentPadding][QuackButtonStyle.contentPadding]을
 * 제공하는 의미가 없어집니다. 따라서 컴포넌트의 사이즈가 하드코딩됐다면 개발자의 의도를 존중한다는 원칙하에
 * 컴포넌트의 사이즈가 중첩으로 확장되는 일을 예방하고자 [contentPadding][QuackButtonStyle.contentPadding]
 * 옵션을 무시합니다. 예를 들어 `Modifier.height(10.dp)`로 컴포넌트 높이를 명시했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(vertical=10.dp)`을 제공했다고 해봅시다. 이런 경우에는
 * [contentPadding][QuackButtonStyle.contentPadding]이
 * 무시되고 버튼의 높이가 10dp로 적용됩니다. 컴포넌트 사이즈를 명시하면서 패딩을 적용하고 싶다면
 * [contentPadding][QuackButtonStyle.contentPadding] 대신에 [Modifier.padding]을 사용하세요.
 * [LayoutModifier]를 사용하는 흔한 [Modifier]로는 [Modifier.size], [Modifier.height], [Modifier.width] 등이
 * 있습니다. [LayoutModifierNode]를 사용하는 [Modifier]는 [contentPadding][QuackButtonStyle.contentPadding] 무시
 * 옵션이 아직 지원되지 않습니다. ([#636](https://github.com/duckie-team/quack-quack-android/issues/636))
 *
 * ### 배치 정책
 *
 * [style.contentPadding][QuackButtonStyle.contentPadding]은 항상 버튼의 텍스트를 기준으로
 * 적용됩니다. 예를 들어 버튼의 아이콘을 leading과 trailing을 모두 제공했고,
 * [contentPadding][QuackButtonStyle.contentPadding]으로
 * `QuackPadding(horizontal=10.dp)`를 제공했다면 양끝의 horizontal 패딩이 각각 아이콘을 기준으로
 * 적용되는 게 아닌 버튼의 텍스트를 기준으로 적용됩니다. 따라서 개발자는 [contentPadding][QuackButtonStyle.contentPadding]의 값을
 * 제공할 때 양끝 아이콘을 기준으로 제공하는 게 아닌 가운데 텍스트를 기준으로 제공해야 합니다.
 * 이 정책은 양끝 아이콘이 동적으로 적용될 때 의도하지 않는 버튼 사이즈 변경을 예방하기 위해
 * 고안됐습니다. 예를 들어 `contentPadding: QuackPadding(horizontal=10.dp)`을 양끝 아이콘 기준으로
 * 적용했다고 해봅시다. 처음에는 양끝에 아이콘이 없어서 가운데 텍스트를 기준으로 패딩이 적용됩니다.
 * 이 시점에는 버튼의 너비가 25dp입니다. (왼쪽 패딩 10dp, 텍스트 5dp, 오른쪽 패딩 10dp) 사용자
 * 요청에 의해 양쪽 모두에 5dp의 너비를 갖는 아이콘이 추가되었습니다. 이 시점에서는 양쪽 아이콘이
 * 존재하므로 [contentPadding][QuackButtonStyle.contentPadding]이 양쪽 아이콘을 기준으로 적용되어
 * 버튼의 너비가 35dp입니다. (왼쪽 패딩 10dp, 왼쪽 아이콘 5dp, 텍스트 5dp, 오른쪽 아이콘 5dp,
 * 오른쪽 패딩 10dp) 즉, 의도하지 않게 버튼의 너비가 10dp 증가하였습니다. 이러한 상황을 예방하기
 * 위해 이 정책이 사용됩니다.
 *
 * ### 사용 가능 데코레이터
 *
 * |                 style             | [icons][Modifier.icons] |                       description
 *                       |
 * | :-------------------------------: | :---------------------: |
 * :-----------------------------------------------------: |
 * |  [Large][QuackLargeButtonStyle]  |            ⭕           |                                    
 *                      |
 * | [Medium][QuackMediumButtonStyle] |            ⭕           |                                    
 *                      |
 * |  [Small][QuackSmallButtonStyle]  |            ❌           | 버튼의 너비가 좁기에 아이콘 데코레이터를 사용할 수 없습니다.
 * |
 *
 * This component uses [QuackButtonStyle.SecondaryRoundSmall] as the token value for `style`.
 *
 * This document was automatically generated by [QuackButton].
 * If any contents are broken, please check the original document.
 *
 * @param enabled 활성화 상태 여부
 * @param text 중앙에 표시할 텍스트
 * @param rippleEnabled 클릭했을 때 리플 애니메이션을 적용할지 여부
 * @param onClick 클릭했을 때 실행할 람다식. [enabled]이 true일 때만 작동합니다.
 */
@Casa
@Composable
@NonRestartableComposable
@ExperimentalQuackQuackApi
@SugarRefer("team.duckie.quackquack.ui.QuackButton")
public fun QuackSecondaryRoundSmallButton(
  modifier: Modifier = sugar(),
  enabled: Boolean = sugar(),
  @CasaValue("\"QuackButton is experimental\"") text: String,
  rippleEnabled: Boolean = sugar(),
  @CasaValue("{}") onClick: () -> Unit,
): Unit {
  QuackButton(
    modifier = modifier,
    enabled = enabled,
    style = QuackButtonStyle.SecondaryRoundSmall,
    text = text,
    rippleEnabled = rippleEnabled,
    onClick = onClick,
  )
}
