/*
 * Designed and developed by Duckie Team 2023.
 *
 * Licensed under the MIT.
 * Please see full license: https://github.com/duckie-team/quack-quack-android/blob/2.x.x/LICENSE
 */

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.buildCodeBlock
import com.squareup.kotlinpoet.withIndent
import java.io.File
import kotlinx.collections.immutable.ImmutableList

private const val GeneratedComment = "This file was automatically generated by casa-processor.\n" +
        "Do not modify it arbitrarily."
private const val FormatterOffComment = "\n@formatter:off"

private val suppressAnnotation = AnnotationSpec
    .builder(Suppress::class)
    .addMember(
        "%S, %S, %S, %S, %S, %S, %S, %S, %S",
        "NoConsecutiveBlankLines",
        "PackageDirectoryMismatch",
        "Wrapping",
        "TrailingCommaOnCallSite",
        "ArgumentListWrapping",
        "RedundantVisibilityModifier",
        "UnusedImport",
        "NoUnusedImports",
        "ktlint",
    )
    .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
    .build()

private val requiredImports = listOf(
    "kotlinx.collections.immutable.persistentListOf",
    "kotlinx.collections.immutable.toImmutableList",
    "androidx.compose.runtime.Composable",
)

private const val SugarReferSn = "SugarRefer"
private const val CasaFqn = "team.duckie.quackquack.casa.annotation.Casa"
private const val CasaValueSn = "CasaValue"
private val CasaModelCn = ClassName(
    packageName = "team.duckie.quackquack.casa.material",
    "CasaModel",
)

internal class CasaProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val casaPath: String?,
) {
    fun resolve(resolver: Resolver): List<KSAnnotated> {
        @Suppress("UNCHECKED_CAST")
        val casas = resolver
            .getSymbolsWithAnnotation(CasaFqn) as Sequence<KSFunctionDeclaration>

        generateCasaModels(
            codeGenerator = codeGenerator,
            logger = logger,
            casas = casas,
            casaPath = casaPath,
        )

        return casas.filterNot(KSAnnotated::validate).toList()
    }
}

private fun KSFunctionDeclaration.parseSugarRefer(): String {
    val sugarRefer = annotations.singleOrNullStrict { annotation ->
        annotation.shortName.asString() == SugarReferSn
    } ?: error("casa-processor only supports sugar components.")
    return sugarRefer.arguments.first().value as String
}

private fun KSFunctionDeclaration.toCasaComponentLiteralWithImport(): Pair<String, String> {
    val import = "team.duckie.quackquack.ui.sugar.${simpleName.asString()}"
    val parameterValueMap = parameters.mapNotNull { parameter ->
        if (parameter.hasDefault) {
            return@mapNotNull null
        }
        val name = parameter.name!!.asString()
        val value = parameter.annotations.singleOrNullStrict { annotation ->
            annotation.shortName.asString() == CasaValueSn
        }
        if (value != null) {
            name to value.arguments.single().value as String
        } else if (parameter.type.resolve().isMarkedNullable) {
            name to "null"
        } else {
            error("Argument $name is non-null and no `CasaValue` was provided.")
        }
    }
    val componentLiteral = buildString {
        appendLine("${simpleName.asString()}(")
        parameterValueMap.forEach { (name, value) ->
            appendLineWithIndent("$name = $value,")
        }
        append(")")
    }

    return import to componentLiteral
}

private fun StringBuilder.appendCasaComponentPairWithImport(casa: KSFunctionDeclaration): Pair<String, StringBuilder> {
    val name = casa.simpleName.asString()
    val (import, componentLiteral) = casa.toCasaComponentLiteralWithImport()
    val component = "{ $componentLiteral }"
    return import to append("\"$name\" to $component")
}

private fun createCasaModelPropertySpecWithImports(
    domain: String,
    name: String,
    casas: List<KSFunctionDeclaration>,
): Pair<List<String>, PropertySpec> {
    val imports = casas.first().parameters.map { parameter ->
        parameter.type.resolve().declaration.qualifiedName!!.asString()
    }.toMutableList()
    val kdocString = casas.first().docString.orEmpty()
        .split("This document was auto-generated.")
        .first()
        .trimIndent()
    val components = buildString {
        appendLine("persistentListOf<Pair<String, @Composable () -> Unit>>(")
        casas.forEach { casa ->
            appendCasaComponentPairWithImport(casa = casa).first.let { import ->
                imports += import
            }
            appendLine(",")
        }
        append(").toImmutableList()")
    }

    val casaModelPropertySpec = PropertySpec
        .builder(
            name = "${domain}${name}CasaModel",
            type = CasaModelCn,
        )
        .addModifiers(KModifier.PRIVATE)
        .initializer(
            codeBlock = buildCodeBlock {
                addStatement("CasaModel(")
                withIndent {
                    addStatement("name = %S,", name)
                    addStatement("domain = %S,", domain)
                    addStatement("kdocDefaultSection = %S,", kdocString)
                    addStatement("components = %L,", components)
                }
                addStatement(")")
            },
        )
        .build()

    return imports to casaModelPropertySpec
}

private fun generateCasaModels(
    codeGenerator: CodeGenerator,
    logger: KSPLogger,
    casas: Sequence<KSFunctionDeclaration>,
    casaPath: String?,
) {
    val imports = mutableListOf<String>().also { imports ->
        imports += requiredImports
    }
    val casasWithDomainGroup = casas.groupBy { declaration ->
        declaration.requireContainingFile.fileName.removeSuffix(".kt")
    }
    val groupedCasasWithNameGroup = buildMap(capacity = casasWithDomainGroup.size) {
        casasWithDomainGroup.forEach { (domain, casas) ->
            val casasWithNameGroup = casas.groupBy { casa ->
                casa.parseSugarRefer().substringAfterLast(".")
            }
            set(domain, casasWithNameGroup)
        }
    }
    val casaModelPropertySpecs = buildList {
        groupedCasasWithNameGroup.forEach { (domain, casasWithNameGroup) ->
            casasWithNameGroup.forEach { (name, casas) ->
                @Suppress("WRONG_ANNOTATION_TARGET", "LocalVariableName")
                val (_imports, casaModelPropertySpec) = createCasaModelPropertySpecWithImports(
                    domain = domain,
                    name = name,
                    casas = casas,
                )
                imports += _imports
                add(casaModelPropertySpec)
            }
        }
    }
    val casaModelPropertySpecsAccessor = PropertySpec
        .builder(
            name = "casaModels",
            type = ImmutableList::class.asClassName().parameterizedBy(CasaModelCn),
        )
        .initializer(
            codeBlock = buildCodeBlock {
                addStatement("persistentListOf(")
                withIndent {
                    casaModelPropertySpecs.forEach { casaModelPropertySpec ->
                        addStatement("${casaModelPropertySpec.name},")
                    }
                }
                addStatement(")")
            },
        )
        .addModifiers(KModifier.PUBLIC)
        .build()
    val casaModelFileSpec = FileSpec
        .builder(
            packageName = "",
            fileName = "CasaModels",
        )
        .addFileComment(GeneratedComment)
        .addFileComment(FormatterOffComment)
        .addAnnotation(suppressAnnotation)
        .apply {
            // memberImports += if (packageName.isNotEmpty()) {
            //   Import("$packageName.$import")
            // } else {
            //   Import(import)
            // }
            addImport(packageName = "", imports)
            casaModelPropertySpecs.forEach(::addProperty)
        }
        .addProperty(casaModelPropertySpecsAccessor)
        .build()

    generateFile(
        codeGenerator = codeGenerator,
        fileSpec = casaModelFileSpec,
        path = casaPath,
        logger = logger,
    )
}

private fun generateFile(
    codeGenerator: CodeGenerator,
    fileSpec: FileSpec,
    path: String?,
    logger: KSPLogger,
) {
    val generatedPath: String
    if (path == null) {
        val fileOutstream = codeGenerator.createNewFile(
            dependencies = Dependencies.Empty,
            packageName = fileSpec.packageName,
            fileName = fileSpec.name,
        )
        fileOutstream.writer().use(fileSpec::writeTo)
        generatedPath = fileSpec.packageName + "/" + fileSpec.name + ".kt"
    } else {
        val file = File(path, "${fileSpec.name}.kt").also { file ->
            if (!file.exists()) {
                file.parentFile?.mkdirs()
                file.createNewFile()
            }
        }
        file.writeText(fileSpec.toString())
        generatedPath = file.path
    }
    logger.warn("[CASA] generated at $generatedPath")
}
