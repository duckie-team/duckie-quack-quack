/*
 * Designed and developed by Duckie Team 2023.
 *
 * Licensed under the MIT.
 * Please see full license: https://github.com/duckie-team/quack-quack-android/blob/2.x.x/LICENSE
 */

package poet

import ComposableCn
import SugarFqn
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.buildCodeBlock
import com.squareup.kotlinpoet.withIndent
import ir.SugarIrData
import ir.SugarParameter
import java.io.File
import org.jetbrains.kotlin.ir.declarations.name
import org.jetbrains.kotlin.ir.types.classFqName
import org.jetbrains.kotlin.name.FqName
import team.duckie.quackquack.sugar.material.GeneratedFile
import team.duckie.quackquack.sugar.material.SugarCompilerApi
import team.duckie.quackquack.sugar.material.SugarRefer

private const val GeneratedComment = "This file was automatically generated by core-sugar-processor-kotlinc.\n" +
        "Do not modify it arbitrarily."

private val suppressAnnotation = AnnotationSpec
    .builder(Suppress::class)
    .addMember(
        "%S, %S, %S, %S, %S, %S, %S, %S",
        "NoConsecutiveBlankLines",
        "ModifierParameter",
        "RedundantUnitReturnType",
        "Wrapping",
        "TrailingCommaOnCallSite",
        "NoUnitReturn",
        "ArgumentListWrapping",
        "ktlint",
    )
    .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
    .build()

@Suppress(
    "OPT_IN_CAN_ONLY_BE_USED_AS_ANNOTATION",
    "OPT_IN_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_OPT_IN",
)
private val sugarCompilerOptInAnnotation = AnnotationSpec
    .builder(OptIn::class)
    .addMember("%T::class", SugarCompilerApi::class)
    .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
    .build()

@OptIn(SugarCompilerApi::class)
private val generatedFileMarkerAnnotation = AnnotationSpec
    .builder(GeneratedFile::class)
    .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
    .build()

internal fun generateSugarComponentFiles(
    irDatas: List<SugarIrData>,
    sugarPath: String,
) {
    val fileGroupedIrDatas = irDatas.groupBy { irData ->
        irData.file.name
    }

    fileGroupedIrDatas.forEach { (fileName, irDatas) ->
        val (imports, funSpecs) = irDatas.toFunSpecsWithImports()
        val ktSpec = FileSpec
            .builder(
                packageName = sugarPath.bestGuessToKotlinPackageName(),
                fileName = fileName.substringBeforeLast("."),
            )
            .addFileComment(GeneratedComment)
            .addAnnotation(suppressAnnotation)
            .addAnnotation(sugarCompilerOptInAnnotation)
            .addAnnotation(generatedFileMarkerAnnotation)
            .addImports(imports.toMutableList().apply { add(SugarFqn) })
            .addFunctions(funSpecs)
            .build()

        File(sugarPath, fileName).also { file ->
            if (!file.exists()) {
                file.parentFile.mkdirs()
                file.createNewFile()
            }
        }.writeText(ktSpec.toString())
    }
}

private fun List<SugarIrData>.toFunSpecsWithImports(): Pair<List<FqName>, List<FunSpec>> {
    val imports = mutableListOf<FqName>()
    val funSpecs = mutableListOf<FunSpec>()
    forEach { sugarIrData ->
        imports += sugarIrData.referFqn
        sugarIrData.tokenFqExpressions.forEach { tokenFqExpression ->
            @Suppress("WRONG_ANNOTATION_TARGET", "LocalVariableName")
            val (_imports, funSpec) = sugarIrData.toFunSpecWithImports(tokenFqExpression)
            imports += _imports
            funSpecs += funSpec
        }
    }
    return imports to funSpecs
}

private fun SugarIrData.toFunSpecWithImports(tokenFqExpression: String): Pair<List<FqName>, FunSpec> {
    val imports = mutableListOf<FqName>()

    @OptIn(SugarCompilerApi::class)
    val sugarReferAnnotation = AnnotationSpec
        .builder(SugarRefer::class)
        .addMember("%S", referFqn.asString())
        .build()

    val sugarName = toSugarComponentName(tokenFqExpression)
    val sugarBody = buildCodeBlock {
        addStatement("%L(", referFqn.shortName().asString())
        withIndent {
            parameters.forEach { parameter ->
                imports += parameter.type.classFqName!!
                imports += parameter.imports

                val parameterName = parameter.name.asString()
                val parameterValue = if (parameter.isToken) tokenFqExpression else parameterName
                addStatement("%L = %L,", parameterName, parameterValue)
            }
        }
        addStatement(")")
    }

    val funSpec = FunSpec
        .builder(sugarName)
        .addAnnotation(ComposableCn)
        .addAnnotation(sugarReferAnnotation)
        .addModifiers(KModifier.PUBLIC)
        .addParameters(parametersWithoutToken.map(SugarParameter::toParameterSpec))
        .addCode(sugarBody)
        .addKdoc(kdoc)
        .build()

    return imports to funSpec
}
