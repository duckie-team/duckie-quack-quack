/*
 * Designed and developed by Duckie Team 2023.
 *
 * Licensed under the MIT.
 * Please see full license: https://github.com/duckie-team/quack-quack-android/blob/2.x.x/LICENSE
 */

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.buildCodeBlock
import java.io.File

private const val GeneratedComment = "This file was automatically generated by aide-processor.\n" +
        "Do not modify it arbitrarily."
private const val FormatterOffComment = "\n@formatter:off"

private val suppressAnnotation = AnnotationSpec
    .builder(Suppress::class)
    .addMember(
        "%S, %S, %S, %S, %S, %S",
        "NoConsecutiveBlankLines",
        "PackageDirectoryMismatch",
        "Wrapping",
        "TrailingCommaOnCallSite",
        "ArgumentListWrapping",
        "ktlint",
    )
    .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
    .build()

private fun createQuackComponentsFileSpec(groupedComponents: List<Pair<String, Set<String>>>): FileSpec {
    val quackComponents = PropertySpec
        .builder(
            name = "quackComponents",
            type = Map::class.asTypeName().parameterizedBy(
                String::class.asTypeName(),
                String::class.asTypeName(),
            ),
        )
        .addModifiers(KModifier.INTERNAL)
        .initializer(
            codeBlock = buildCodeBlock {
                beginControlFlow("run")
                addStatement(
                    "val aide = mutableMapOf<%T, %T>()",
                    String::class,
                    String::class,
                )
                groupedComponents.forEach { (domain, components) ->
                    addStatement("")
                    components.forEach { component ->
                        addStatement("aide[%S] = %S", component, domain)
                    }
                }
                addStatement("")
                addStatement("aide")
                endControlFlow()
            },
        )
        .build()

    return FileSpec
        .builder(
            packageName = "",
            fileName = "QuackComponents",
        )
        .addFileComment(GeneratedComment)
        .addFileComment(FormatterOffComment)
        .addAnnotation(suppressAnnotation)
        .addProperty(quackComponents)
        .build()
}

internal fun generateQuackComponents(
    codeGenerator: CodeGenerator,
    logger: KSPLogger,
    symbols: Sequence<KSFunctionDeclaration>,
    aidePath: String?,
) {
    val quackComponents = symbols.toDomainWithSimpleNameGroups()
    val quackComponentsFileSpec = createQuackComponentsFileSpec(quackComponents)

    generateFile(
        codeGenerator = codeGenerator,
        fileSpec = quackComponentsFileSpec,
        path = aidePath,
        logger = logger,
    )
}

private fun createAideModifiersFileSpec(groupedModifiers: List<Pair<String, Set<String>>>): FileSpec {
    val aideModifiers = PropertySpec
        .builder(
            name = "aideModifiers",
            type = Map::class.asTypeName().parameterizedBy(
                String::class.asTypeName(),
                List::class.asTypeName().parameterizedBy(String::class.asTypeName()),
            ),
        )
        .addModifiers(KModifier.INTERNAL)
        .initializer(
            codeBlock = buildCodeBlock {
                beginControlFlow("run")
                addStatement(
                    "val aide = mutableMapOf<%T, %T>()",
                    String::class,
                    List::class.parameterizedBy(String::class),
                )
                groupedModifiers.forEach { (domain, modifiers) ->
                    addStatement("")
                    addStatement("aide[%S] = %L", domain, modifiers.toLiteralListString())
                    modifiers.forEach { modifier ->
                        addStatement("aide[%S] = %L()", "_$modifier", "emptyList")
                    }
                }
                addStatement("")
                addStatement("aide")
                endControlFlow()
            },
        )
        .build()

    return FileSpec
        .builder(
            packageName = "",
            fileName = "AideModifiers",
        )
        .addFileComment(GeneratedComment)
        .addFileComment(FormatterOffComment)
        .addAnnotation(suppressAnnotation)
        .addProperty(aideModifiers)
        .build()
}

internal fun generateAideModifiers(
    codeGenerator: CodeGenerator,
    logger: KSPLogger,
    symbols: Sequence<KSFunctionDeclaration>,
    aidePath: String?,
) {
    val aideModifiers = symbols.toDomainWithSimpleNameGroups()
    val aideModifiersFileSpec = createAideModifiersFileSpec(aideModifiers)

    generateFile(
        codeGenerator = codeGenerator,
        fileSpec = aideModifiersFileSpec,
        path = aidePath,
        logger = logger,
    )
}

private fun generateFile(
    codeGenerator: CodeGenerator,
    fileSpec: FileSpec,
    path: String?,
    logger: KSPLogger,
) {
    val generatedPath: String
    if (path == null) {
        val fileOutstream = codeGenerator.createNewFile(
            dependencies = Dependencies.Empty,
            packageName = fileSpec.packageName,
            fileName = fileSpec.name,
        )
        fileOutstream.writer().use(fileSpec::writeTo)
        generatedPath = fileSpec.packageName + "/" + fileSpec.name + ".kt"
    } else {
        val file = File(path, "${fileSpec.name}.kt").also { file ->
            if (!file.exists()) {
                file.parentFile.mkdirs()
                file.createNewFile()
            }
        }
        file.writeText(fileSpec.toString())
        generatedPath = file.path
    }
    logger.warn("[AIDE] generated at $generatedPath")
}

private fun Sequence<KSFunctionDeclaration>.toDomainWithSimpleNameGroups(): List<Pair<String, Set<String>>> {
    return this
        .groupBy { value ->
            val fileName = value.requireContainingFile.fileName
            fileName.removeSuffix(".kt")
        }
        .map { (domain, values) ->
            val valueSimpleNames = values.map { value ->
                value.simpleName.asString()
            }
            domain to valueSimpleNames.toSet()
        }
}
